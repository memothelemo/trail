--!strict
--!optimize 2

local Symbol = require("@src/core/symbol")

local Level = {
    Trace = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4,
}

-- Similar to TypeScript's enum system
Level[Level.Trace] = "Trace"
Level[Level.Debug] = "Debug"
Level[Level.Info] = "Info"
Level[Level.Warn] = "Warn"
Level[Level.Error] = "Error"

local LevelFilter = {
    OFF = 0,
    TRACE = 1,
    DEBUG = 2,
    INFO = 3,
    WARN = 4,
    ERROR = 5,
}

LevelFilter[LevelFilter.OFF] = "OFF"
LevelFilter[LevelFilter.TRACE] = "TRACE"
LevelFilter[LevelFilter.DEBUG] = "DEBUG"
LevelFilter[LevelFilter.INFO] = "INFO"
LevelFilter[LevelFilter.WARN] = "WARN"
LevelFilter[LevelFilter.ERROR] = "ERROR"

export type Level = number
export type LevelFilter = number

local EXPLICIT_MARKER = Symbol.named("<trail.core.Parent.Explicit>")
local Parent
Parent = {
    Root = Symbol.named("<trail.core.Parent.Root>"),
    Current = Symbol.named("<trail.core.Parent.Current>"),
    Explicit = function(id: Id)
        return { [EXPLICIT_MARKER] = true, id = id }
    end,

    isExplicit = function(data): boolean
        if type(data) ~= "table" then
            return false
        end
        local success, value = pcall(function()
            return data[EXPLICIT_MARKER]
        end)
        return success and value == true
    end,

    isRoot = function(data): boolean
        return data == Parent.Root
    end,

    isCurrent = function(data): boolean
        return data == Parent.Current
    end,

    getParentId = function(data: Parent): string?
        if Parent.isExplicit(data) then
            return data[EXPLICIT_MARKER]
        end
        return nil
    end,
}

--[[
    Identifies a span within the context of a subscriber.

    They are generated by a current Subscriber for each span as
    it is created, by the Subscriber::newSpan method.
]]
export type Id = string

export type FieldSet = { string }
export type ValueSet = { { any } } -- [string, any][]

export type Parent = any

export type Metadata = {
    -- The name of the span described by this metadata.
    name: string,

    -- Part of the system that the span that this metadata
    -- describes occurred in.
    target: string,

    -- The level of verbosity of the described span.
    level: Level,

    -- The source script where the span occurred.
    script: Script,

    -- Line number in the source code file where the span occurred
    line: number,

    -- The names of the key-value fields attached to the
    -- described span or event
    fields: FieldSet,

    -- The kind of the callsite.
    kind: "EVENT" | "SPAN",
}

--[[
    Attributes provided to a subscriber describing a new
    span when it is created.
]]
export type Attributes = {
    metadata: Metadata,
    values: ValueSet,
    parent: Parent,
}

local Attributes = {}

function Attributes.new(metadata: Metadata, values: ValueSet): Attributes
    return {
        metadata = metadata,
        values = values,
        parent = Parent.Current,
    }
end

function Attributes.newRoot(metadata: Metadata, values: ValueSet): Attributes
    return {
        metadata = metadata,
        values = values,
        parent = Parent.Root,
    }
end

function Attributes.childOf(parent: Id, metadata: Metadata, values: ValueSet): Attributes
    return {
        metadata = metadata,
        values = values,
        parent = Parent.Explicit(parent),
    }
end

function Attributes.getParent(attributes: Attributes): Id?
    return Parent.getParentId(attributes.parent)
end

-- A set of fields recorded by a span.
export type Record = {
    values: ValueSet,
}

--[[
    `Event`s represent single points in time where something occurred
    during the execution of a program.
]]
export type Event = {
    fields: ValueSet,
    metadata: Metadata,
    parent: Parent,
}

local Event = {}

function Event.new(metadata: Metadata, fields: ValueSet): Event
    return {
        fields = fields,
        metadata = metadata,
        parent = Parent.Current,
    }
end

-- selene: allow(unused_variable)
function Event.dispatch(metadata: Metadata, fields: ValueSet)
    error("Cannot execute `Event.dispatch()`, maybe it is a bug!")
end

function Event.newChildOf(parent: Id, metadata: Metadata, fields: ValueSet): Event
    parent = if parent ~= nil then Parent.Explicit(parent) else Parent.Root
    return {
        fields = fields,
        metadata = metadata,
        parent = parent,
    }
end

-- selene: allow(unused_variable)
function Event.childOf(parent: Id, metadata: Metadata, fields: ValueSet)
    error("Cannot execute `Event.childOf()`, maybe it is a bug!")
end

function Event.isRoot(event: Event): boolean
    return event.parent == Parent.Root
end

function Event.isContextual(event: Event): boolean
    return event.parent == Parent.Current
end

function Event.getParentId(event: Event): Id?
    return Parent.getParentId(event.parent)
end

return {
    Attributes = Attributes,
    Event = Event,
    Level = Level,
    LevelFilter = LevelFilter,
    Parent = Parent,
}
